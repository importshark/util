const fs = require("fs");
const cryptojs = require("crypto-js");
const { zip } = require("zip-a-folder")

const isFile = (path) => {
    return new Promise((resolve, reject) => {
        fs.lstat(path, (err, stats) => {
            if(err) reject(err)
            resolve(stats.isFile());
        })
    })
}
const isDirectory = (path) => {
    return new Promise((resolve, reject) => {
        fs.lstat(path, (err, stats) => {
            if(err) reject(err)
            resolve(stats.isDirectory());
        })
    })
}
const getType = async (path) => {

    if(await isFile(path) == true) {
        return "file"
    } else if(await isDirectory(path) == true) {
        return "directory"
    } else {
        return "unknown"
    }

}
const exists = async (path) => {
    return new Promise((resolve) => {
        fs.access(path, fs.F_OK, (err) => {
            if(err) {
                resolve(false)
            } else {
                resolve(true);
            }
        })
    })  
}
const getFileSizeInMegabytes = async (path) => {
    return new Promise((resolve, reject) => {
        fs.stat(path, (err, stats) => {
            if(err) reject(err);
            const fileSizeInBytes = stats.size;
            const fileSizeInMegabytes = fileSizeInBytes / 1000000.0;
            resolve(fileSizeInMegabytes);
        })
    })
}
const encryptMessage = (data, password) => {

    const encryptedMessage = cryptojs.AES.encrypt(data, password).toString();
    return encryptedMessage;

}
const decryptMessage = (encryptedData, password) => {

    const decryptedMessageBytes = cryptojs.AES.decrypt(encryptedData, password);
    const decryptedMessage = decryptedMessageBytes.toString(cryptojs.enc.Utf8);
    return decryptedMessage;

}
const createDirectory = (path) => {
    return new Promise((resolve) => {
        fs.mkdir(path, { recursive: true }, () => {
            resolve(this);
        });
    })
}

class File {

    constructor(path, name) {

        this.path = path;
        this.name = name;

    }
    read() {
        return new Promise((resolve, reject) => {
            fs.readFile(this.path, (err, data) => {
                if(err) reject(err);

                resolve(data.toString(), this);
            })
        })
    }
    async exists() {
        
        const fileExists = exists(this.path);
        return fileExists;

    }
    async create() {
        if(await this.exists()) {
            return this;
        } else {
            await this.write("");
            return this;
        }
    }
    write(content) {
        return new Promise((resolve, reject) => {
            fs.writeFile(this.path, content, (err) => {
                if (err) reject(err);
                resolve(this);
            });
        })
    }
    async getFileSize() {

        const size = await getFileSizeInMegabytes(this.path);
        return size;

    }
    async encrypt(password) {

        const data = await this.read();
        const encryptedData = encryptMessage(data, password);
        await this.write(encryptedData)
        return this;

    }
    async decrypt(password) {

        const data = await this.read();
        try {
            const decryptedData = decryptMessage(data, password);
            await this.write(decryptedData);
            return true;
        } catch {
            return false;
        }

    }
    async copy(destinationPath) {
        return new Promise((resolve, reject) => {
            fs.copyFile(this.path, destinationPath, (err) => {
                if(err) reject(err);
                resolve(new File(destinationPath));
            });
        })
    }
    async delete() {
        return new Promise((resolve, reject) => {
            fs.unlink(this.path, (err) => {
                if(err) reject(err);
                resolve(this);
            });
        })
    }
    async readAsJSON() {

        if(await this.exists()) {

            const content = await this.read();
            if(content == "") {
                return {};
            } else {
                return JSON.parse(content);
            }

        } else {
            return {}
        }

    }
    async writeAsJSON(object) {

        if(!await this.exists()) await this.create();
        await this.write(JSON.stringify(object));

    }

}
class Directory {

    constructor(path, name) {

        this.path = path;
        this.name = name;

    }
    async exists() {

        const exists = await exists(this.path);
        return exists;

    }
    list() {
        return new Promise((resolve, reject) => {
            fs.readdir(this.path, async (err, files) => {
                if(err) reject(err);
                const listing = files.map(async (file) => {

                    const type = await getType(this.path + "/" + file);
                    if(type == "file") {
                        return new File(this.path + "/" + file, file)
                    } else if(type == "directory") {
                        return new Directory(this.path + "/" + file, file)
                    }
                    
                })
                const resolvedListing = await Promise.all(listing);
                resolve(resolvedListing)
            });
        })
    }
    async listFiles() {
        
        const listing = await this.list();
        const files = listing.filter((object) => object instanceof File)
        return files;

    }
    async listDirectories() {

        const listing = await this.list();
        const directories = listing.filter((object) => object instanceof Directory)
        return directories;

    }
    async create() {

        await createDirectory(this.path);
        return this;

    }
    async encryptFiles(password) {

        const files = await this.listFiles();

        const promises = files.map(async (file) => {
            await file.encrypt(password);
        })
        await Promise.all(promises);

        return this;

    }
    async decryptFiles(password) {

        const files = await this.listFiles();

        const promises = files.map(async (file) => {
            await file.decrypt(password);
        })
        await Promise.all(promises);

        return this;

    }
    async decrypt(password) {

        await this.decryptFiles(password);

        const directories = await this.listDirectories();
        
        const promises = directories.map(async (directory) => {
            await directory.decrypt(password);
        })
        await Promise.all(promises);

        return this;

    } 
    async encrypt(password) {

        await this.encryptFiles(password);

        const directories = await this.listDirectories();
        
        const promises = directories.map(async (directory) => {
            await directory.encrypt(password);
        })
        await Promise.all(promises);

        return this;

    }
    async zip(destinationPath) {

        await zip(this.path, destinationPath);
        return this;

    }
    async copyFiles(destinationDirectory) {

        const files = await this.listFiles();
        const promises = files.map((file) => file.copy(destinationDirectory + "/" + file.name));
        await Promise.all(promises);

    }
    async copy(destinationDirectory) {

        const copiedDirectory = new Directory(destinationDirectory);
        await copiedDirectory.create();

        await this.copyFiles(destinationDirectory);

        const directories = await this.listDirectories();

        const promises = directories.map(async (directory) => {
            await new Directory(destinationDirectory + "/" + directory.name).create();
            await directory.copy(destinationDirectory + "/" + directory.name);
        });
        await Promise.all(promises);

        return copiedDirectory;

    }

}

module.exports = {
    File,
    Directory,
    isFile,
    isDirectory,
    getType,
    exists,
    getFileSizeInMegabytes,
    encryptMessage,
    decryptMessage,
    createDirectory
}