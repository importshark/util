"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getClientID = exports.processAssets = exports.combine = exports.classPathResolver = exports.throwErr = exports.getErr = exports.fsSanitizer = exports.assetTag = exports.lawyer = exports.getCpuArch = exports.getOS = void 0;
const os_1 = require("os");
const files_js_1 = require("../objects/files.js");
const config_js_1 = require("../config.js");
const crypto_1 = require("crypto");
/**Gets the current operating system GMLL thinks it is running under */
function getOS() {
    const operatingSystem = (0, os_1.platform)();
    switch (operatingSystem) {
        case ("win32"):
            return "windows";
        case ("darwin"):
            return "osx";
        default:
            return "linux";
    }
}
exports.getOS = getOS;
const OS = getOS();
/**Gets the current CPU architecture for the current running machine. May not be that accurate for Mac OS */
function getCpuArch() {
    let architecture = (0, os_1.arch)(); //ProgramFiles(Arm)
    if (OS == "windows") {
        if ("ProgramFiles(Arm)" in process.env)
            architecture = "arm64"; //For arm64
        else if ("PROCESSOR_ARCHITEW6432" in process.env)
            architecture = "x64"; //For AMD64 with 32-bit node
        else if (architecture != "x64")
            architecture = "x86"; //To filter out ia32 or x32 and translate that to x86
    }
    return architecture;
}
exports.getCpuArch = getCpuArch;
const archX = getCpuArch();
/**The processor that handles the rules set out in the version.json for a set version.*/
function lawyer(rules, properties = {}) {
    let end = true, end2 = false;
    for (let i = 0; i < rules.length; i++) {
        if (rules[i].features)
            Object.keys(rules[i].features).forEach(e => {
                if (rules[i].features[e] && !properties[e])
                    end = false;
            });
        const os = !rules[i].os || ((!rules[i].os.name || rules[i].os.name == OS) &&
            (!rules[i].os.version || (0, os_1.version)().match(rules[i].os.version)) &&
            (!rules[i].os.arch || (rules[i].os.arch == archX)));
        if (rules[i].action == "disallow" && os) {
            end = false;
        }
        else if (rules[i].action == "allow" && os) {
            // end = true && end;
            end2 = true;
        }
    }
    return (end && end2);
}
exports.lawyer = lawyer;
/**
 * Generates the sha1 dir listings for assets and compressed runtime files
 */
function assetTag(path, sha1) {
    const file = path.getDir(sha1.substring(0, 2));
    file.mkdir();
    return file;
}
exports.assetTag = assetTag;
/**Sanitizes folder names for use in file paths */
function fsSanitizer(text) {
    return text.normalize("NFKC").trim().toLowerCase().replace(/[,!@#$%^&*()[\]{};:"<>\\/?~`'|=+\s\t]/g, "_");
}
exports.fsSanitizer = fsSanitizer;
/**Used to throw error messages that are easy to find in a busy terminal */
function getErr(message) {
    const header = "\n\n\x1b[31m\x1b[1m[--------------ERROR--------------ERROR--------------!GMLL!--------------ERROR--------------ERROR--------------]\x1b[0m\n\n";
    return header + message + header + Error().stack;
}
exports.getErr = getErr;
/**Used to throw error messages that are easy to find in a busy terminal */
function throwErr(message) {
    throw getErr(message);
}
exports.throwErr = throwErr;
/**Used to get maven class paths */
function classPathResolver(name, sub = "") {
    const namespec = name.split(":", 4);
    return `${namespec[0].replace(/\./g, "/")}/${namespec[1]}/${namespec[2]}/${namespec[1]}-${namespec[2]}${(namespec[3] ? '-' + namespec[3].replace(/:/g, "-") : "")}${sub.length > 0 ? "-" + sub : ""}.jar`;
}
exports.classPathResolver = classPathResolver;
/**Takes two different version.json files and combines them */
function combine(ob1, ob2) {
    Object.keys(ob2).forEach(e => {
        if (!ob1[e]) {
            ob1[e] = ob2[e];
        }
        else if (typeof ob1[e] == typeof ob2[e]) {
            if (ob1[e] instanceof Array) {
                ob1[e] = [...ob2[e], ...ob1[e]];
            }
            else if (typeof ob1[e] == "string") {
                ob1[e] = ob2[e];
            }
            else if (ob1[e] instanceof Object) {
                ob1[e] = combine(ob1[e], ob2[e]);
            }
        }
        else {
            ob1[e] = ob2[e];
        }
    });
    return ob1;
}
exports.combine = combine;
/**
 * Used to export assets from the modern asset index system the game uses for 1.8+ to a format legacy versions of the game can comprehend.
 * This is how we get sound working in deprecated versions of Minecraft
 */
function processAssets(assetManifest) {
    if (assetManifest.virtual || assetManifest.map_to_resources) {
        const root = (0, config_js_1.getAssets)();
        const file = root.getDir("legacy", assetManifest.virtual ? "virtual" : "resources").mkdir();
        Object.entries(assetManifest.objects).forEach(o => {
            const key = o[0];
            const obj = o[1];
            const to = file.getFile(...key.split("/")).mkdir();
            const finalFile = assetTag(root.getDir("objects"), obj.hash).getFile(obj.hash);
            finalFile.copyTo(to);
        });
    }
}
exports.processAssets = processAssets;
/**
 * Used to get a unique ID to recognize this machine. Used by mojang in some snapshot builds.
 * We're just making sure it is sufficiently random
 */
function getClientID(forceNew = false) {
    (0, config_js_1.isInitialized)();
    const path = (0, config_js_1.getMeta)().index.getFile("ClientID.txt");
    let data;
    if (!path.exists() || forceNew) {
        data = (0, files_js_1.stringify)({
            Date: Date.now(),
            UUID: (0, crypto_1.randomUUID)(),
            network: (0, crypto_1.createHash)('sha256').update((0, files_js_1.stringify)((0, os_1.networkInterfaces)())).digest("base64"),
            user: (0, crypto_1.createHash)('sha256').update((0, files_js_1.stringify)((0, os_1.userInfo)())).digest("base64"),
            provider: "GMLL",
        });
        data = (0, crypto_1.createHash)('sha512').update(data).digest("base64");
        path.write(data);
    }
    else {
        data = path.read();
    }
    return data;
}
exports.getClientID = getClientID;
