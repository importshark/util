"use strict";
/* eslint-disable @typescript-eslint/no-explicit-any */
/*
 * This is the core of the download manager. No code from the main thread should interact with it!
 * If GMLL is unable to reach this library then it will use a slower fallback.
 *
 * Redefine the property __get in the config module to change where GMLL looks for this file.
 * ^ If you want to reenable the faster downloader.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const files_js_1 = require("../objects/files.js");
const worker_threads_1 = require("worker_threads");
const { processCMD, failCMD, getCMD, postCMD, zipDir } = worker_threads_1.workerData;
async function load(a, retry = 0) {
    const o = a.data;
    try {
        await files_js_1.File.process(o, new files_js_1.Dir(...zipDir));
        worker_threads_1.parentPort.postMessage({ cmd: processCMD, key: o.key });
        return;
    }
    catch (e) {
        if (retry <= 3) {
            retry++;
            worker_threads_1.parentPort.postMessage({ cmd: failCMD, type: "retry", key: o.key, err: e });
            await load(a, retry);
            return;
        }
        console.error("[GMLL]: procedural failure : " + new files_js_1.Dir(...o.path));
        worker_threads_1.parentPort.postMessage({ cmd: failCMD, type: "system", key: o.path, err: e });
        worker_threads_1.parentPort.postMessage({ cmd: processCMD, key: o.key });
    }
}
worker_threads_1.parentPort.on("message", async (a) => {
    if (a.data && a.cmd == postCMD)
        await load(a);
});
worker_threads_1.parentPort.postMessage({ cmd: getCMD, type: "system" });
