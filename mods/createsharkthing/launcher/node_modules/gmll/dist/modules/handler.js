"use strict";
/**The internal java and version manifest handler for GMLL */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getJavaPath = exports.importLink = exports.installForge = exports.getLatest = exports.getManifest = exports.getManifests = void 0;
const tslib_1 = require("tslib");
const config_js_1 = require("./config.js");
const downloader_js_1 = require("./downloader.js");
const util_js_1 = require("./internal/util.js");
const child_process_1 = require("child_process");
const files_js_1 = require("./objects/files.js");
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const instance_js_1 = tslib_1.__importDefault(require("./objects/instance.js"));
/**
 * Compiles all manifest objects GMLL knows about into a giant array. This will include almost all fabric versions and any installed version of forge.
 * GMLL can still launch a version if it is not within this folder, although it is not recommended
 * @returns a list of Manifest files GMLL knows definitely exist.
 */
function getManifests() {
    (0, config_js_1.isInitialized)();
    const versionManifest = [];
    const root = (0, config_js_1.getMeta)().manifests;
    root.ls().forEach(e => {
        if (e.sysPath().endsWith("json") && e instanceof files_js_1.File) {
            const v = e.toJSON();
            if (v instanceof Array)
                versionManifest.push(...v);
            else
                versionManifest.push(v);
        }
    });
    return versionManifest;
}
exports.getManifests = getManifests;
const forgiacCodes = {
    100: "Could not create virtual folder",
    101: "Could not create junction link",
    102: "Please use Windows Vista or later",
    200: "User cancelled request",
    201: "Invalid installation jar",
    202: "Forge failed to install",
    300: "Parameter error"
};
function findManifest(version, manifests) {
    const v = version.toLocaleLowerCase().trim();
    let manifest = manifests.find(e => { try {
        return e.id.toLocaleLowerCase().trim() == v;
    }
    catch {
        return false;
    } }); //|| { id: version, type: "unknown" };
    if (!manifest) {
        console.warn("[GMLL]: attempting to generate manifest files");
        const root = (0, config_js_1.getMeta)().manifests;
        const versionJson = (0, config_js_1.getVersions)().getFile(version, `${version}.json`);
        if (versionJson.exists()) {
            let f = root.getFile(`${version}.json`);
            let i = 1;
            while (f.exists())
                f = root.getFile(`${version}_${i++}.json`);
            try {
                const vj = versionJson.toJSON();
                const mf = {
                    id: vj.id || versionJson.name.split(".")[0],
                    base: vj.inheritsFrom,
                    releaseTime: vj.releaseTime,
                    time: vj.time,
                    type: vj.type || "generated"
                };
                f.write(mf);
            }
            catch (e) {
                console.error("[GMLL]: failed to compile manifest from version json");
            }
        }
        else {
            console.warn(`[GMLL]: no version json (at ${versionJson.sysPath()}) found, I hope you know what you are doing!`);
        }
        manifest = { id: version, type: "unknown" };
    }
    if (manifest.base) {
        const man2 = findManifest(manifest.base, manifests);
        manifest.releaseTime = man2.releaseTime;
        manifest.time = man2.time;
        manifest.complianceLevel = man2.complianceLevel;
    }
    return manifest;
}
const spTag = ["latest", "latest:release", "latest:snapshot"];
/**Gets a specific version manifest based on the version ID provided
 * @param version the version ID
 * @returns a version manifest. It will be of type "unknown" if the specific manifest is not in the manifest database.
 */
function getManifest(version) {
    if (spTag.includes(version)) {
        const lt = getLatest();
        switch (version) {
            case ("latest:snapshot"):
                version = lt.snapshot;
                break;
            case ("latest:release"):
            case ("latest"):
                version = lt.release;
                break;
        }
    }
    (0, config_js_1.isInitialized)();
    const manifests = getManifests();
    return findManifest(version, manifests);
}
exports.getManifest = getManifest;
/**Gets the latest release and snapshot builds.*/
function getLatest() {
    (0, config_js_1.isInitialized)();
    const file = (0, config_js_1.getMeta)().index.getFile("latest.json");
    if (file.exists())
        return file.toJSON();
    else
        return { "release": "1.17.1", "snapshot": "21w42a" };
}
exports.getLatest = getLatest;
async function installForge(forgeInstallerJar, forgiacArgs = ["--virtual", (0, config_js_1.getVersions)().sysPath()]) {
    const path = (0, config_js_1.getInstances)().getDir(".forgiac");
    const manifest = path.getDir(".manifest_" + Date.now()).mkdir();
    if (typeof forgeInstallerJar == "string")
        forgeInstallerJar = new files_js_1.File(forgeInstallerJar);
    const fRun = config_js_1.onUnsupportedArm ? "java-runtime-arm" : "java-runtime-gamma";
    await (0, downloader_js_1.runtime)(fRun);
    const javaPath = getJavaPath(fRun);
    const logFile = path.getFile("log.txt");
    const args = ["-jar", (await (0, downloader_js_1.getForgiac)()).sysPath(), " --log", logFile.sysPath(), ...forgiacArgs, (0, config_js_1.getlibraries)().sysPath(), "--mk_manifest", manifest.sysPath()];
    if (forgeInstallerJar) {
        args.push("--installer", forgeInstallerJar.sysPath());
    }
    path.mkdir();
    (0, config_js_1.emit)("jvm.start", "Forgiac", path.sysPath());
    const s = (0, child_process_1.spawn)(javaPath.sysPath(), args, { "cwd": path.sysPath() });
    s.stdout.on('data', (chunk) => (0, config_js_1.emit)("jvm.stdout", "Forgiac", chunk));
    s.stderr.on('data', (chunk) => (0, config_js_1.emit)("jvm.stderr", "Forgiac", chunk));
    const err = await new Promise(e => s.on('exit', e));
    if (err != 0) {
        throw { "Error": "forge.install.failure", code: err, message: forgiacCodes[err] || "unknown error" };
    }
    const forgeManifest = manifest.ls();
    if (forgeManifest.length < 1) {
        throw { "Error": "manifest.not.found", code: 400, message: "Manifest file not found?" };
    }
    const manifestFile = forgeManifest[0];
    if (!(manifestFile instanceof files_js_1.File)) {
        throw { "Error": "manifest.is.folder", code: 401, message: "Manifest file is a directory?" };
    }
    const result = manifestFile.toJSON();
    manifestFile.moveTo((0, config_js_1.getMeta)().manifests.getFile(manifestFile.getName()));
    manifest.rm();
    return result;
}
exports.installForge = installForge;
async function importLink(url, name) {
    const r = await (0, node_fetch_1.default)(url + "/.meta/api.json");
    if (!r.ok)
        throw "Could not find the api doc";
    const v = await r.json();
    if (v.version != 1) {
        throw "Incompatible version ID detected";
    }
    const manfile = (0, util_js_1.fsSanitizer)(v.name) + ".json";
    const manifest = (await (0, config_js_1.getMeta)().manifests.getFile(manfile).download(url + "/.meta/manifest.json", { sha1: v.sha })).toJSON();
    // console.log(manfile)
    if (!name)
        return manifest;
    return new instance_js_1.default({ version: manifest.id, name: name }).save();
}
exports.importLink = importLink;
/**
 * Gets the path to an installed version of Java. GMLL manages these versions and they're not provided by the system.
 * @param java the name of the Java runtime. Based on the names Mojang gave them.
 * @returns The location of the have executable.
 */
function getJavaPath(java = "jre-legacy") {
    if ((0, util_js_1.getOS)() == "windows") {
        const f = (0, config_js_1.getRuntimes)().getFile(java, "bin", "javaw.exe");
        if (f.exists())
            return f;
        else
            (0, config_js_1.getRuntimes)().getFile(java, "bin", "java.exe");
    }
    else
        return (0, config_js_1.getRuntimes)().getFile(java, "bin", "java");
}
exports.getJavaPath = getJavaPath;
