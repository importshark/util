import { open as open$1, fromBuffer, fromFd } from 'yauzl';

/**
 * Open a yauzl zip
 * @param target The zip path or buffer or file descriptor
 * @param options The option to open
 */
async function open(target, options = { lazyEntries: true, autoClose: false }) {
    return new Promise((resolve, reject) => {
        function handleZip(err, zipfile) {
            if (err || !zipfile) {
                reject(err !== null && err !== void 0 ? err : new Error("Cannot open zip!"));
            }
            else {
                resolve(zipfile);
            }
        }
        if (typeof target === "string") {
            open$1(target, options, handleZip);
        }
        else if (target instanceof Buffer) {
            fromBuffer(target, options, handleZip);
        }
        else {
            fromFd(target, options, handleZip);
        }
    });
}
/**
 * Open the entry readstream for the zip file
 * @param zip The zip file object
 * @param entry The entry to open
 * @param options The options to open stream
 */
function openEntryReadStream(zip, entry, options) {
    return new Promise((resolve, reject) => {
        function handleStream(err, stream) {
            if (err || !stream) {
                reject(err);
            }
            else {
                resolve(stream);
            }
        }
        if (options) {
            zip.openReadStream(entry, options, handleStream);
        }
        else {
            zip.openReadStream(entry, handleStream);
        }
    });
}
/**
 * Read the entry to buffer
 * @param zip The zip file object
 * @param entry The entry to open
 * @param options The options to open stream
 */
async function readEntry(zip, entry, options) {
    const stream = await openEntryReadStream(zip, entry, options);
    const buffers = [];
    await new Promise((resolve, reject) => {
        stream.on("data", (chunk) => { buffers.push(chunk); });
        stream.on("end", resolve);
        stream.on("error", reject);
    });
    return Buffer.concat(buffers);
}
/**
 * Get the async entry generator for the zip file
 * @param zip The zip file
 */
async function* walkEntriesGenerator(zip) {
    let ended = false;
    let error;
    let resume = () => { };
    let wait = new Promise((resolve) => {
        resume = resolve;
    });
    const entries = [];
    const onEntry = (e) => {
        entries.push(e);
        resume();
    };
    const onEnd = () => {
        ended = true;
        resume();
    };
    const onError = (e) => {
        error = e;
        resume();
    };
    zip.addListener("entry", onEntry)
        .addListener("end", onEnd)
        .addListener("error", onError);
    try {
        while (!ended) {
            if (zip.lazyEntries) {
                zip.readEntry();
            }
            await wait;
            // if error, throw error
            if (error) {
                throw error;
            }
            // if entries read, yield entries
            while (entries.length > 0 && !ended) {
                ended = !!(yield entries.pop());
            }
            // reset wait
            wait = new Promise((resolve) => {
                resume = resolve;
            });
        }
    }
    finally {
        zip.removeListener("entry", onEntry)
            .removeListener("end", onEnd)
            .removeListener("error", onError);
    }
}
/**
 * Walk all the entries of the zip and once provided entries are all found, then terminate the walk process
 * @param zip The zip file
 * @param entries The entry to read
 */
async function filterEntries(zip, entries) {
    const remaining = new Set(entries);
    const record = {};
    for await (const entry of walkEntriesGenerator(zip)) {
        if (remaining.size === 0) {
            break;
        }
        if (remaining.has(entry.fileName)) {
            remaining.delete(entry.fileName);
            record[entry.fileName] = entry;
        }
    }
    return entries.map((name) => record[name]);
}
/**
 * Walk all the entries of a unread zip file
 * @param zip The unread zip file
 * @param entryHandler The handler to recieve entries. Return true or Promise<true> to stop the walk
 */
async function walkEntries(zip, entryHandler) {
    const itr = walkEntriesGenerator(zip);
    for await (const entry of itr) {
        const result = await entryHandler(entry);
        if (result) {
            break;
        }
    }
}
function getEntriesRecord(entries) {
    const record = {};
    for (const entry of entries) {
        record[entry.fileName] = entry;
    }
    return record;
}
/**
 * Walk all entries of the zip file
 * @param zipFile The zip file object
 */
async function readAllEntries(zipFile) {
    const entries = [];
    for await (const entry of walkEntriesGenerator(zipFile)) {
        entries.push(entry);
    }
    return entries;
}

export { filterEntries, getEntriesRecord, open, openEntryReadStream, readAllEntries, readEntry, walkEntries, walkEntriesGenerator };
//# sourceMappingURL=index.esm.js.map
