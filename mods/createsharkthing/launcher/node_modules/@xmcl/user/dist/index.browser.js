import { v4, v3 } from 'uuid';

const httpRequester = async (option) => {
    const url = new URL(option.url);
    let body = undefined;
    let headers = option.headers;
    if (option.body) {
        switch (option.bodyType || "json") {
            case "json":
                headers["Content-Type"] = "application/json";
                body = JSON.stringify(option.body);
                break;
            case "search":
                url.search = new URLSearchParams(option.body).toString();
                break;
            case "formMultiPart":
                body = new FormData();
                for (let [key, value] of body) {
                    if (value instanceof Uint8Array) {
                        value = new File([value], "", { type: "image/png" });
                    }
                    body.append(key, value);
                }
                break;
        }
    }
    const response = await fetch(url.toString(), {
        body,
        headers,
        method: option.method,
    });
    return {
        body: await response.text(),
        statusCode: response.status,
        statusMessage: response.statusText,
    };
};
async function verify(data, signature, pemKey) {
    function stringToBuffer(s) {
        const byteArray = new Uint8Array(s.length);
        for (let i = 0; i < s.length; i++) {
            byteArray[i] = s.charCodeAt(i);
        }
        return byteArray;
    }
    const option = {
        name: "RSASSA-PKCS1-v1_5",
        hash: "sha1",
    };
    if (typeof pemKey === "string") {
        pemKey = pemKey.replace("\n", "")
            .replace("-----BEGIN PRIVATE KEY-----", "")
            .replace("-----END PRIVATE KEY-----", "");
        pemKey = atob(pemKey);
        pemKey = stringToBuffer(pemKey);
    }
    const key = await crypto.subtle.importKey("pkcs8", pemKey, option, false, ["verify"]);
    return crypto.subtle.verify(option, key, stringToBuffer(signature), stringToBuffer(data));
}
function decodeBase64(b) {
    return atob(b);
}

const loginPayload = (clientToken, option) => ({
    agent: { name: "Minecraft", version: 1 },
    requestUser: "requestUser" in option ? option.requestUser : true,
    clientToken,
    username: option.username,
    password: option.password,
});
const refreshPayload = (clientToken, option) => ({
    clientToken,
    accessToken: option.accessToken,
    requestUser: typeof option.requestUser === "boolean" ? option.requestUser : false,
});
/**
 * Random generate a new token by uuid v4. It can be client or auth token.
 * @returns a new token
 */
function newToken() {
    return v4().replace(/-/g, "");
}
class Authenticator {
    /**
     * Create a client for `Yggdrasil` service, given API and clientToken.
     * @param clientToken The client token uuid. It will generate a new one if it's absent.
     * @param api The api for this client.
     */
    constructor(clientToken, api) {
        this.clientToken = clientToken;
        this.api = api;
    }
    post(endpoint, payload) {
        return post(this.api.hostName + endpoint, payload);
    }
    /**
     * Login to the server by username and password. Notice that the auth server usually have the cooldown time for login.
     * You have to wait for about a minute after one approch of login, to login again.
     *
     * @param option The login options, contains the username, password
     * @throws This may throw the error object with `statusCode`, `statusMessage`, `type` (error type), and `message`
     */
    login(option) {
        return this.post(this.api.authenticate, loginPayload(this.clientToken, option));
    }
    /**
     * Determine whether the access/client token pair is valid.
     *
     * @param option The access token
     */
    validate(option) {
        return this.post(this.api.validate, {
            clientToken: this.clientToken,
            accessToken: option.accessToken,
        }).then(() => true, () => false);
    }
    /**
     * Invalidate an access token and client token
     *
     * @param option The tokens
     */
    invalidate(option) {
        return this.post(this.api.invalidate, {
            clientToken: this.clientToken,
            accessToken: option.accessToken,
        }).then(() => { });
    }
    /**
     * Refresh the current access token with specific client token.
     * Notice that the client token and access token must match.
     *
     * You can use this function to get a new token when your old token is expired.
     *
     * @param option The access token
     */
    refresh(option) {
        return this.post(this.api.refresh, refreshPayload(this.clientToken, option));
    }
    signout(option) {
        return this.post(this.api.signout, {
            username: option.username,
            password: option.password,
        }).then(() => { });
    }
}
/**
 * The default Mojang API
 */
const AUTH_API_MOJANG = {
    hostName: "https://authserver.mojang.com",
    authenticate: "/authenticate",
    refresh: "/refresh",
    validate: "/validate",
    invalidate: "/invalidate",
    signout: "/signout",
};
function post(url, payload) {
    return httpRequester({
        url,
        method: "POST",
        body: payload,
        headers: {},
        bodyType: "json",
    }).then(({ statusCode, body, statusMessage }) => {
        try {
            if (statusCode >= 200 && statusCode < 300) {
                if (!body) {
                    return undefined;
                }
                return JSON.parse(body);
            }
            else {
                const errorBody = JSON.parse(body);
                const err = {
                    ...errorBody,
                    error: typeof errorBody.error === "string" ? errorBody.error : "General",
                    statusCode,
                    statusMessage,
                };
                throw err;
            }
        }
        catch (e) {
            if (typeof e.error === "string") {
                throw e;
            }
            throw {
                error: "General",
                statusCode,
                statusMessage,
                body,
            };
        }
    });
}
/**
 * Login to the server by username and password. Notice that the auth server usually have the cooldown time for login.
 * You have to wait for about a minute after one approch of login, to login again.
 *
 * @param option The login options, contains the username, password and clientToken
 * @param api The API of the auth server
 * @throws This may throw the error object with `statusCode`, `statusMessage`, `type` (error type), and `message`
 */
async function login(option, api = AUTH_API_MOJANG) {
    return post(api.hostName + api.authenticate, loginPayload(option.clientToken || newToken(), option));
}
/**
 * Refresh the current access token with specific client token.
 * Notice that the client token and access token must match.
 *
 * You can use this function to get a new token when your old token is expired.
 *
 * @param option The tokens
 * @param api The API of the auth server
 */
function refresh(option, api = AUTH_API_MOJANG) {
    return post(api.hostName + api.refresh, refreshPayload(option.clientToken, option));
}
/**
 * Determine whether the access/client token pair is valid.
 *
 * @param option The tokens
 * @param api The API of the auth server
 */
async function validate(option, api = AUTH_API_MOJANG) {
    try {
        await post(api.hostName + api.validate, {
            accessToken: option.accessToken,
            clientToken: option.clientToken,
        });
        return true;
    }
    catch (e) {
        return false;
    }
}
/**
 * Invalidate an access/client token pair
 *
 * @param option The tokens
 * @param api The API of the auth server
 */
async function invalidate(option, api = AUTH_API_MOJANG) {
    await post(api.hostName + api.invalidate, {
        accessToken: option.accessToken,
        clientToken: option.clientToken,
    });
}
/**
 * Signout user by username and password
 *
 * @param option The username and password
 * @param api The API of the auth server
 */
async function signout(option, api = AUTH_API_MOJANG) {
    await post(api.hostName + api.signout, {
        username: option.username,
        password: option.password,
    });
}
/**
 * Create an offline auth. It'll ensure the user game profile's `uuid` is the same for the same `username`.
 *
 * @param username The username you want to have in-game.
 */
function offline(username) {
    const prof = {
        id: v3(username, "00000000-0000-0000-0000-000000000000"),
        name: username,
    };
    return {
        accessToken: newToken(),
        clientToken: newToken(),
        selectedProfile: prof,
        availableProfiles: [prof],
        user: {
            id: v3(username, "00000000-0000-0000-0000-000000000000"),
            username: username,
        },
    };
}

var GameProfile;
(function (GameProfile) {
    (function (Texture) {
        function isSlim(o) {
            return o.metadata ? o.metadata.model === "slim" : false;
        }
        Texture.isSlim = isSlim;
        function getModelType(o) {
            return isSlim(o) ? "slim" : "steve";
        }
        Texture.getModelType = getModelType;
    })(GameProfile.Texture || (GameProfile.Texture = {}));
})(GameProfile || (GameProfile = {}));

// export enum Status {
//     GREEN, YELLOW, RED,
// }
// /**
//  * Get the all mojang server statuses
//  *
//  * @param provider
//  */
// export async function getServiceStatus(): Promise<{ [server: string]: Status }> {
//     const { body } = await request({
//         url: "https://status.mojang.com/check", method: "GET",
//         headers: {}
//     });
//     return JSON.parse(body).reduce((a: any, b: any) => Object.assign(a, b), {});
// }
/**
 * Check if user need to verify its identity. If this return false, should perform such operations:
 * 1. call `getChallenges` get all questions
 * 2. let user response questions
 * 3. call `responseChallenges` to send user responsed questions, if false, redo `2` step.
 *
 * If you don't let user response challenges when this return false. You won't be able to get/set user texture from Mojang server.
 *
 * *(This only work for Mojang account. Third party definitly doesn't have such thing)*
 * @param accessToken You user access token.
 */
async function checkLocation(accessToken) {
    // "ForbiddenOperationException";
    // "Current IP is not secured";
    const { statusCode } = await httpRequester({
        url: "https://api.mojang.com/user/security/location",
        method: "GET",
        headers: { Authorization: `Bearer: ${accessToken}` },
    });
    return statusCode === 204;
}
/**
 * Get the user set challenge to response.
 *
 * @param accessToken The user access token
 * @returns User pre-defined questions
 */
async function getChallenges(accessToken) {
    const { body, statusCode, statusMessage } = await httpRequester({
        url: "https://api.mojang.com/user/security/challenges",
        method: "GET",
        headers: { Authorization: `Bearer: ${accessToken}` },
    });
    if (statusCode < 200 || statusCode >= 300) {
        throw { error: "General", statusCode, statusMessage };
    }
    const challenges = JSON.parse(body);
    return challenges;
}
/**
 * Response the challeges from `getChallenges`.
 *
 * @param accessToken The access token
 * @param responses Your responses
 * @returns True for correctly responsed all questions
 */
async function responseChallenges(accessToken, responses) {
    const { statusCode } = await httpRequester({
        url: "https://api.mojang.com/user/security/location",
        method: "POST",
        body: responses,
        bodyType: "json",
        headers: { Authorization: `Bearer: ${accessToken}` },
    });
    return statusCode >= 200 && statusCode < 300;
}

var ProfileServiceAPI;
(function (ProfileServiceAPI) {
    /**
     * Replace `${uuid}` string into uuid param
     * @param api The api
     * @param uuid The uuid will be replaced
     */
    function getProfileUrl(api, uuid) {
        return api.profile.replace("${uuid}", uuid);
    }
    ProfileServiceAPI.getProfileUrl = getProfileUrl;
    /**
     * Replace `${name}` string into name param
     * @param api The api
     * @param name The name will be replaced
     */
    function getProfileByNameUrl(api, name) {
        return api.profileByName.replace("${name}", name);
    }
    ProfileServiceAPI.getProfileByNameUrl = getProfileByNameUrl;
    /**
     * Replace uuid string into `${uuid}`, and type string into `${type}`
     * @param api The api
     * @param uuid The uuid string
     * @param type The type string
     */
    function getTextureUrl(api, uuid, type) {
        return api.texture.replace("${uuid}", uuid).replace("${type}", type);
    }
    ProfileServiceAPI.getTextureUrl = getTextureUrl;
})(ProfileServiceAPI || (ProfileServiceAPI = {}));
/**
 * The default Mojang API
 */
const PROFILE_API_MOJANG = {
    publicKey: `-----BEGIN PUBLIC KEY-----
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAylB4B6m5lz7jwrcFz6Fd
/fnfUhcvlxsTSn5kIK/2aGG1C3kMy4VjhwlxF6BFUSnfxhNswPjh3ZitkBxEAFY2
5uzkJFRwHwVA9mdwjashXILtR6OqdLXXFVyUPIURLOSWqGNBtb08EN5fMnG8iFLg
EJIBMxs9BvF3s3/FhuHyPKiVTZmXY0WY4ZyYqvoKR+XjaTRPPvBsDa4WI2u1zxXM
eHlodT3lnCzVvyOYBLXL6CJgByuOxccJ8hnXfF9yY4F0aeL080Jz/3+EBNG8RO4B
yhtBf4Ny8NQ6stWsjfeUIvH7bU/4zCYcYOq4WrInXHqS8qruDmIl7P5XXGcabuzQ
stPf/h2CRAUpP/PlHXcMlvewjmGU6MfDK+lifScNYwjPxRo4nKTGFZf/0aqHCh/E
AsQyLKrOIYRE0lDG3bzBh8ogIMLAugsAfBb6M3mqCqKaTMAf/VAjh5FFJnjS+7bE
+bZEV0qwax1CEoPPJL1fIQjOS8zj086gjpGRCtSy9+bTPTfTR/SJ+VUB5G2IeCIt
kNHpJX2ygojFZ9n5Fnj7R9ZnOM+L8nyIjPu3aePvtcrXlyLhH/hvOfIOjPxOlqW+
O5QwSFP4OEcyLAUgDdUgyW36Z5mB285uKW/ighzZsOTevVUG2QwDItObIV6i8RCx
FbN2oDHyPaO5j1tTaBNyVt8CAwEAAQ==
-----END PUBLIC KEY-----`,
    texture: "https://api.mojang.com/user/profile/${uuid}/${type}",
    profile: "https://sessionserver.mojang.com/session/minecraft/profile/${uuid}",
    profileByName: "https://api.mojang.com/users/profiles/minecraft/${name}",
};
/**
 * Get all the textures of this GameProfile and cache them.
 *
 * @param profile The game profile from the profile service
 * @param cache Should we cache the texture into url? Default is `true`.
 */
function getTextures(profile) {
    if (!profile.properties || !profile.properties.textures) {
        return undefined;
    }
    const content = decodeBase64(profile.properties.textures);
    return JSON.parse(content);
}
/**
 * Fetch the GameProfile by uuid.
 *
 * @param uuid The unique id of user/player
 * @param option the options for this function
 */
async function lookup(uuid, option = {}) {
    const api = option.api || PROFILE_API_MOJANG;
    const unsigned = "unsigned" in option ? option.unsigned : !api.publicKey;
    const { body, statusCode, statusMessage, } = await httpRequester({
        url: ProfileServiceAPI.getProfileUrl(api, uuid),
        method: "GET",
        headers: {},
        body: { unsigned },
        bodyType: "search",
    });
    if (statusCode !== 200) {
        throw {
            error: "General",
            statusCode,
            statusMessage,
        };
    }
    const o = JSON.parse(body);
    if (o.properties && o.properties instanceof Array) {
        const properties = o.properties;
        const to = {};
        for (const prop of properties) {
            if (prop.signature && api.publicKey && !await verify(prop.value, prop.signature, api.publicKey)) {
                console.warn(`Discard corrupted prop ${prop.name}: ${prop.value} as the signature mismatched!`);
            }
            else {
                to[prop.name] = prop.value;
            }
        }
        o.properties = to;
    }
    return o;
}
/**
 * Look up the GameProfile by username in game.
 * This will return the UUID of the name at the timestamp provided.
 * `?at=0` can be used to get the UUID of the original user of that username, but, it only works if the name was changed at least once, or if the account is legacy.

 * The timestamp is a UNIX timestamp (without milliseconds)
 * When the at parameter is not sent, the current time is used
 * @param name The username in game.
 * @param option the options of this function
 * @throws ProfileLookupException
 */
function lookupByName(name, option = {}) {
    const api = option.api || PROFILE_API_MOJANG;
    const time = option.timestamp || 0;
    let target = ProfileServiceAPI.getProfileByNameUrl(api, name);
    let form;
    if (time) {
        form = { at: (time / 1000) };
    }
    return httpRequester({
        url: target,
        method: "GET",
        headers: {},
        body: form,
        bodyType: "search",
    }).then(({ statusCode, statusMessage, body }) => {
        if (statusCode === 200) {
            return JSON.parse(body);
        }
        else if (statusCode === 204) {
            throw {
                error: "NoPlayerFoundException",
                errorMessage: "",
                statusCode,
                statusMessage
            };
        }
        else {
            let errorBody;
            try {
                errorBody = JSON.parse(body);
            }
            catch (_a) {
                errorBody = {};
            }
            throw {
                error: errorBody.error || "General",
                errorMessage: errorBody.errorMessage,
                statusCode,
                statusMessage
            };
        }
    });
}
/**
 * Set texture by access token and uuid.
 * If the texture is undefined, it will clear the texture to default steve.
 */
async function setTexture(option, api = PROFILE_API_MOJANG) {
    var _a, _b;
    const urlString = ProfileServiceAPI.getTextureUrl(api, option.uuid, option.type);
    const headers = {
        Authorization: `Bearer: ${option.accessToken}`
    };
    if (!option.texture) {
        // delete texture
        const response = await httpRequester({
            url: urlString,
            method: "DELETE",
            headers,
        });
        if (response.statusCode >= 300) {
            throw new Error(`Status code ${response.statusCode}!`);
        }
    }
    else if ("data" in option.texture) {
        // upload texture
        const response = await httpRequester({
            url: urlString,
            method: "PUT",
            body: {
                model: ((_a = option.texture.metadata) === null || _a === void 0 ? void 0 : _a.model) || "",
                file: { type: "image/png", value: option.texture.data },
            },
            bodyType: "formMultiPart",
            headers,
        });
        if (response.statusCode >= 300) {
            throw new Error(`Status code ${response.statusCode}!`);
        }
    }
    else if ("url" in option.texture) {
        // set texture
        const response = await httpRequester({
            url: urlString,
            method: "POST",
            body: {
                model: ((_b = option.texture.metadata) === null || _b === void 0 ? void 0 : _b.model) || "",
                url: option.texture.url,
            },
            bodyType: "search",
            headers,
        });
        if (response.statusCode >= 300) {
            throw new Error(`Status code ${response.statusCode}!`);
        }
    }
    else {
        throw new Error("Illegal Option Format!");
    }
}
/**
 * A lookuper will maintain your last time of lookup. It will prevent the lookup frequency exceed the rate limit
 */
class ProfileLookuper {
    constructor(api, 
    /**
     * The rate limit of this lookuper
     */
    rateLimit = 6000) {
        this.api = api;
        this.rateLimit = rateLimit;
        this.lookupRecord = {};
    }
    lookup(uuid) {
        const now = Date.now();
        const api = this.api;
        const rateLimit = this.rateLimit;
        const lastLookup = this.lookupRecord[uuid];
        if (!lastLookup) {
            // never lookup
            this.lookupRecord[uuid] = {
                deferredLookup: undefined,
                lastLookupTime: Date.now(),
            };
            return lookup(uuid, { api });
        }
        let lastLookupTime = lastLookup.lastLookupTime;
        let deferredLookup = lastLookup.deferredLookup;
        if (now - lastLookupTime < rateLimit) {
            // lookup too freq
            if (!deferredLookup) {
                // no one looked
                deferredLookup = new Promise((resolve) => {
                    setTimeout(() => {
                        this.lookupRecord[uuid] = {
                            deferredLookup: undefined,
                            lastLookupTime: Date.now(),
                        };
                        resolve(lookup(uuid, { api }));
                    }, (now - lastLookupTime - rateLimit));
                });
            }
            lastLookup.deferredLookup = deferredLookup;
            return deferredLookup;
        }
        // not too freq, update the look up time
        lastLookup.lastLookupTime = Date.now();
        return lookup(uuid, { api });
    }
}

export { AUTH_API_MOJANG, Authenticator, GameProfile, PROFILE_API_MOJANG, ProfileLookuper, ProfileServiceAPI, checkLocation, getChallenges, getTextures, invalidate, login, lookup, lookupByName, newToken, offline, refresh, responseChallenges, setTexture, signout, validate };
//# sourceMappingURL=index.browser.js.map
