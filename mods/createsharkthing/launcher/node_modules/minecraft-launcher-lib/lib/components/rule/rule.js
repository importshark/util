"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RuleAction = exports.Rule = void 0;

var _platform = require("../platform");

let RuleAction;
exports.RuleAction = RuleAction;

(function (RuleAction) {
  RuleAction["ALLOW"] = "allow";
  RuleAction["DISALLOW"] = "disallow";
})(RuleAction || (exports.RuleAction = RuleAction = {}));

class Rule {
  static from(child, parent) {
    if (!parent) {
      if (child instanceof Rule) return child;
      parent = {};
    }

    return new Rule(child.action, Object.assign({}, parent.os, child.os), Object.assign({}, parent.features, child.features));
  }

  static sanitizeFeatures(features) {
    return Object.fromEntries(Object.entries(features).map(([feature, value]) => [feature, Boolean(value)]));
  }

  constructor(action = RuleAction.ALLOW, os = {}, features = {}) {
    this.action = action;
    this.os = os;
    this.features = features;
  }
  /**
   * Compare the current platform and enabled features with params and features
   * of this rule required for this rule to take action.
   *
   * @param platform The current platform.
   * @param features The enabled or disabled features.
   *
   * @returns The result for this rule.
   */


  isAllowable(platform = {}, features = {}) {
    const currentPlatform = _platform.Platform.from(platform);

    let allowable = true;
    {
      if (this.os.name) {
        allowable = this.compare(this.os.name === currentPlatform.name, this.os.name !== currentPlatform.name);
      }

      if (this.os.version) {
        const result = currentPlatform.version.match(this.os.version);
        allowable = this.compare(Boolean(result), !result);
      }

      if (this.os.arch) {
        allowable = this.compare(this.os.arch === currentPlatform.arch, this.os.arch !== currentPlatform.arch);
      }
    } // compare platform

    {
      const secureRuleFeatures = Rule.sanitizeFeatures(this.features);
      const secureFeatures = Rule.sanitizeFeatures(features); // secure enabled features

      Object.entries(secureRuleFeatures).forEach(([feature, value]) => {
        allowable = this.compare(secureFeatures[feature] === value, secureFeatures[feature] !== value);
      });
    } // compare features

    return allowable;
  }
  /**
   * Compare two boolean values using this rule's action.
   */


  compare(a, b) {
    switch (this.action) {
      case RuleAction.ALLOW:
        return a;

      default:
        return b;
    }
  }

}

exports.Rule = Rule;
//# sourceMappingURL=rule.js.map