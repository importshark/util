"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Library = void 0;

var _rule = require("../rule");

var _platform = require("../platform");

var _argument = require("../argument");

var _libraryDownloads = require("./library-downloads");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Library {
  static from(lib) {
    if (typeof lib !== 'string') {
      if (lib instanceof Library) return lib;
    } else {
      return new Library(lib);
    }

    const {
      name,
      downloads = {},
      extract,
      rules,
      natives
    } = lib;
    if (!name) throw new Error('missing library name');
    return new Library(name, _libraryDownloads.LibraryDownloads.from(downloads, {
      name,
      natives
    }), natives, extract, rules);
  }

  static concatNameWithClassifier(name, classifier) {
    const s = ':';
    const parts = name.split(s);
    const [group, artifact, unsplittedVersion] = parts;
    const [version, versionExtension] = unsplittedVersion.split('@');
    return [group, artifact, version, versionExtension ? classifier + '@' + versionExtension : classifier].join(s);
  }

  constructor(name, downloads = {}, natives = {}, extract = {}, rules = []) {
    _defineProperty(this, "hasNative", (os = _platform.Platform.current.name) => os in this.natives);

    this.name = name;
    this.natives = natives;
    this._downloads = _libraryDownloads.LibraryDownloads.from(downloads, {
      name,
      natives
    });
    const {
      exclude = ['META-INF/']
    } = extract;
    this._extract = {
      exclude
    };
    this._rules = rules.map(rule => _rule.Rule.from(rule));
  }

  get downloads() {
    return this._downloads;
  }

  set downloads(downloads) {
    this._downloads = _libraryDownloads.LibraryDownloads.from(downloads, this);
  }

  get extract() {
    return this._extract;
  }

  get rules() {
    return this._rules;
  }

  set rules(rules) {
    this._rules = rules.map(rule => _rule.Rule.from(rule));
  }
  /**
   * Checks if this library is applicable to the current platform and features.
   *
   * @param platform The current platform.
   * @param features The current featutes.
   *
   * @returns Is library applicable?
   */


  isApplicable(platform = {}, features = {}) {
    return !this.rules.map(rule => rule.isAllowable(platform, features)).includes(false);
  }

  /**
   * Gets its native classifier or throws an error, if library has not native classifier.
   *
   * @param platform The current platform.
   * @param format Format the result?
   *
   * @returns The native classifier.
   */
  getNativeClassifier(platform = {}, format = false) {
    var _arch$match$shift, _arch$match;

    const {
      name,
      arch
    } = _platform.Platform.from(platform);

    const classifier = this.natives[name];
    if (!classifier) throw new Error('library has not native classifier');
    return format ? _argument.Argument.format(classifier, new Map([['arch', (_arch$match$shift = (_arch$match = arch.match(/\d\d/g)) === null || _arch$match === void 0 ? void 0 : _arch$match.shift()) !== null && _arch$match$shift !== void 0 ? _arch$match$shift : '32']])) : classifier;
  }

  toString() {
    return this.name;
  }

  toJSON() {
    const {
      name,
      downloads,
      natives,
      extract,
      rules
    } = this;
    return {
      name,
      downloads,
      natives,
      extract,
      rules
    };
  }

}

exports.Library = Library;
//# sourceMappingURL=library.js.map