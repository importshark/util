"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArtifactExtractTaskEvent = exports.ArtifactExtractTask = void 0;

var yauzl = _interopRequireWildcard(require("yauzl"));

var _path = require("path");

var _mkdirp = _interopRequireDefault(require("mkdirp"));

var _fs = require("fs");

var _artifactTask = require("../artifact-task");

var _util = require("../../../util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

let ArtifactExtractTaskEvent;
exports.ArtifactExtractTaskEvent = ArtifactExtractTaskEvent;

(function (ArtifactExtractTaskEvent) {
  ArtifactExtractTaskEvent["PROGRESS"] = "progress";
  ArtifactExtractTaskEvent["EXCLUDE"] = "exclude";
  ArtifactExtractTaskEvent["FINISH"] = "finish";
  ArtifactExtractTaskEvent["ENTRY"] = "entry";
  ArtifactExtractTaskEvent["ERROR"] = "error";
})(ArtifactExtractTaskEvent || (exports.ArtifactExtractTaskEvent = ArtifactExtractTaskEvent = {}));

class ArtifactExtractTask extends _artifactTask.ArtifactTask {
  constructor(artifact, artifactRoot, extractionRoot, exclude = ['META-INF/']) {
    super(artifact);
    this.artifactRoot = artifactRoot;
    this.extractionRoot = extractionRoot;
    this.exclude = exclude;
  }

  async start() {
    const extractionRootExist = await (0, _util.exists)(this.extractionRoot);

    if (!extractionRootExist) {
      await (0, _mkdirp.default)(this.extractionRoot);
    }

    return new Promise((resolve, reject) => {
      const fileOptions = {
        autoClose: true,
        lazyEntries: true
      };
      const filePath = (0, _path.join)(this.artifactRoot, this.artifact.path);
      yauzl.open(filePath, fileOptions, (err, file) => {
        if (err) {
          return reject(err);
        }

        if (!file) {
          return reject(new Error('cannot open zip file'));
        }

        const progress = {
          total: file.entryCount,
          completed: 0
        };

        const nextEntry = () => {
          progress.completed++;
          this.emit(ArtifactExtractTaskEvent.PROGRESS, progress);
          file.readEntry();
        };

        file.on('entry', entry => {
          const {
            fileName,
            uncompressedSize,
            compressedSize
          } = entry;
          const _entry = {
            fileName,
            uncompressedSize,
            compressedSize
          };
          this.emit(ArtifactExtractTaskEvent.ENTRY, _entry);
          const exclude = this.exclude.map(e => entry.fileName.startsWith(e)).includes(true);

          if (exclude) {
            this.emit(ArtifactExtractTaskEvent.EXCLUDE, fileName);
            return nextEntry();
          }

          file.openReadStream(entry, (err, readStream) => {
            if (err) {
              return reject(err);
            }

            if (!readStream) {
              return reject(new Error('cannot open read stream from zip file'));
            }

            const filePath = (0, _path.join)(this.extractionRoot, fileName);

            if (fileName.endsWith('/')) {
              try {
                _mkdirp.default.sync(filePath);
              } catch (err) {
                this.emit(ArtifactExtractTaskEvent.ERROR, err);
              }

              return nextEntry();
            }

            if ((0, _fs.existsSync)(filePath)) {
              return nextEntry();
            }

            const writeStream = (0, _fs.createWriteStream)(filePath);
            writeStream.on('finish', () => {
              nextEntry();
            }).on('error', err => {
              this.emit(ArtifactExtractTaskEvent.ERROR, err);
            });
            readStream.pipe(writeStream);
          });
        }).on('end', () => {
          this.emit(ArtifactExtractTaskEvent.FINISH);
          resolve(this);
        });
        file.readEntry(); // start read entries
      });
    });
  }

}

exports.ArtifactExtractTask = ArtifactExtractTask;
//# sourceMappingURL=artifact-extract-task.js.map